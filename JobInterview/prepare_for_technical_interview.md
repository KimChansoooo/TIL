# 기술면접 준비


### 1. 오버라이딩(Overriding) vs 오버로딩(Overloading)
***
#### 오버라이딩
상위 클래스 혹은 인터페이스에 존재하는 메서드를 하위 클래스에서 필요에 맞게 <b>_재정의_</b> 하는 것 `동적바인딩`
#### 오버로딩
매개변수의 타입이나 갯수가 다른 메소드를 만드는 것 `정적바인딩`
- 동적 바인딩 : Runtime(파일 실행) 시점에 성격이 결정되는 것
- 정적 바인딩 : Compile(실행 이전) 시점에 성격이 결정되는 것
```java
int a = 1;    // 이 경우 DataType으로 int가 바인딩되는 것과 'a'라는 변수명은 `정적 바인딩`
// '1'이라는 값의 할당은 실행 시에 이루어지는 것으로 `동적 바인딩`
```

### 2. 싱글톤 패턴 (Singleton Pattern)
***
애플리케이션에서 인스턴스를 하나만 만들어 사용하기 위한 패턴</br>
커넥션 풀, 스레드 풀, 디바이스 설정 객체의 경우 인스턴스를 여러 개 만들게 되면 자원을 낭비하거나, 버그를 발생시킬 수 있다.
- 생성자를 private 로 선언하여 new 키워드를 이용한 객체 생성을 막고, getInstance() 함수를 통해서만 미리 생성된 인스턴스를 가져올 수 있게 한다.

```java
import java.security.Signature;
public class Singleton {
    private static Singleton instance = new Singleton();
    public static Signature getInstance() {
        return instance;
    }
    private Singleton() {
//        ...
    }
}
```

### 3. List vs Set
***
#### List : 순서가 있는 Collection으로, Index를 통해 특정 아이템에 접근이 가능하다.
#### Set : 순서를 보장하지 않는 Collection으로, 중복을 허용하지 않는다.
- List의 Contains()는 시간복잡도 O(n)을 가지며, Set의 Contains()는 시간복잡도 O(1)을 가지기 때문에
순서를 보장해야하고 중복을 허용한다면 List를, 중복을 허용하지 않고 순서를 보장할 필요가 없다면 Set을 쓰는 것이 유리하다.
- List를 사용하든, Set을 사용하든 동작에 차이가 없는 상황이라면 HashSet을 사용하는 것이 유리하다.
### 3-1. List 와 ArrayList
***
List는 Interface, ArrayList는 List를 구현한 Class이다.
ArrayList는 가변적인 특징을 가지며, 담는 것 마다 공간이 늘어나 자주 사용된다.

```java
import java.util.ArrayList;
List<Integer> list = new ArrayList();
```
### 3-2. 배열 내부 중복 제거를 위한 방법
***
1. HashSet (`중복을 허용하지 않는 자료구조`)에 배열을 추가하고 중복된 값이 제거되면, 그 HashSet의 요소들을 다시 배열로 변경한다.
2. Stream API의 `distinct()` 함수를 사용하여 중복된 요소를 제거한다.
### 4. RESTful API
***
#### REST (REpresentational State Transfer) : 월드와이드웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 종류
REST의 기본 원칙을 성실하게 지킨 서비스 디자인을 "RESTful 하다." 라고 할 수 있다.
#### REST 아키텍처의 특징
1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
2. 리소스는 URI로 표현되는데, 리소스가 가리키는 것은 `명사`로 표현한다.
3. 행위는 HTTP Method로 표현한다. (GET, POST, PUT, PATCH, DELETE 등)
4. Message는 Header와 Body를 명확하게 분리하여 사용한다.
5. API 버전을 관리한다.
6. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.

### 5. 주소창에 URL을 입력하면 일어나는 일
***
1. 주소창에 URL 입력
2. `Cache`(브라우저나 OS, Router가 보관하는 캐시)에서 DNS Record를 확인
3. DNS(Domain Name System) 조회 `원하는 IP 주소 찾기`
4. 브라우저가 IP주소를 받았다면, 브라우저가 서버와의 TCP 연결을 한다
5. 브라우저가 서버에 HTTP 요청을 보낸다
6. 서버가 요청을 처리하고 JSON, HTML, XML과 같은 형식으로 응답을 보낸다
7. 서버가 HTTP 응답을 보낸다 (상태코드 등)
8. 브라우저에 HTML 콘텐츠가 표시된다

### 6. TCP vs UDP
***
#### TCP (Transfer Control Protocol)
인터넷상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜로, `연결 지향적`이며 `신뢰성`있는 데이터의 전송을 보장한다.
(ex. 편지, 등기)
- TCP는 신뢰성과 데이터의 정확성을 중시하는 응용 프로그램에 적합하며, UDP는 빠른 전송이 중요한 응용 프로그램에 적합하다.
#### UDP (User Datagram Protocol)
데이터를 데이터그램 단위로 처리하는 프로토콜로, 신호 절차 없이 데이터를 전송하며 `비연결성`의 `신뢰성` 없는 데이터 전송이 특징이다.
전송속도는 빠르지만 데이터 손실이 발생할 수 있다. (ex. 메모지, 종이비행기)
- UDP는 TCP에 비해 안정성은 떨어지지만, 더 빠르고 간단해 스트리밍이나 게임과 같은 빠른 속도가 중요한 프로그램에 자주 사용된다

### 7. Spring Framework
***
스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로, 애플리케이션을 빠르게 개발할 수 있도록 다양한 기능을 제공한다.
- 개발 초기에 기본적인 설정과 기술들만 선택하면, 어플리케이션 로직 자체에 집중하여 비즈니스 로직만 구현하면 되게 해주는 프레임워크
- 프레임워크는 '뼈대' 를 의미하며, 사용자가 작성한 코드가 프레임워크에 의해 사용되는 측면에서 라이브러리와 다른 의미이다

### 7-1. Spring의 특징
***
#### 1. 경량 컨테이너 : 자신이 개발에 필요한 라이브러리나 요소들`만` 가져와서 사용
#### 2. 의존성 주입(DI)와 제어의 역전(IoC)
   1. DI(Dependency Injection) : 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는 것이 아닌, 주입받아 사용하는 방법 (이 때문에 낮은 결합도를 가진다)
      - 제어의 역전으로 특정 객체에 필요한 다른 객체를 외부에서 결정해서 연결시키는 것
   2. IoC(Inversion of Control) : 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 역전됨을 의미한다
   3. Spring IoC 컨테이너 : 애플리케이션 컴포넌트의 중앙 저장소로, 빈(Bean) 들의 의존 관계를 설정해준다. `객체의 생성을 책임지고, 의존성을 관리한다.`
   컨테인너를 `Bean Factory`라고도 부르며, Bean Factory에는 여러가지 컨테이너 기능을 추가한 Application Context가 있다.
   - `@Component` `@Controller` `@Service` `@Repository` 와 같은 어노테이션이나 XML 설정을 기반으로 Application Context에 등록한다.
(하나 하나 생성하고 의존성 주입할 필요없이 bean 파일로 등록하면 Spring이 알아서 의존성 주입을 해준다.)
#### 3. 관점 지향 프로그래밍(AOP) : 관점을 기준으로 묶어 개발하는 방식
로그를 찍거나, 메서드 실행 시간을 기록하거나, Input/Output 결과를 따로 보고 싶거나 하는 등의 `실제 서비스 로직과 다른 관심사를 분리하여 개발하는 방식`
* Spring AOP는 메서드 실행시점에서만 AOP를 적용할 수 있고, Spring 컨테이너가 관리할 수 있는 Spring Bean에만 AOP 적용이 가능하다 

### 7-2. Spring vs SpringBoot
***
SpringBoot는 Spring의 단점(`복잡한 초기설정`, `의존성을 주입한 라이브러리의 버전관리`, `별도의 WAS 설치`)을 개선한 Spring Framework이다.
- SpringBoot Starter를 통해 사용할 라이브러리만 선택하여 초기 설정을 할 수 있다
- 내장 서버나 의존성 관리 간소화 같은 장점을 가진다

### 7-3. Spring Bean(빈)
***
Bean(빈)은 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트
#### Spring Bean 등록 방법
1. XML에 직접 등록
2. `@Bean` 어노테이션 사용 (`@Configuration` 클래스 내부에 `@Bean`으로 등록)
3. `@Component`, `@Controller`, `@Service`, `@Repository` 어노테이션을 이용 (`@ComponentScan`을 활용하여 특정 패키지를 Scan)
4. SpringBoot의 자동 설정(`@SpringBootApplication`)을 통한 Bean 관리

### 7-4. Filter vs Interceptor
***
#### 필터(Filter)
필터는 J2EE 표준 스펙 기능으로 디스패처 서블릿(Dispatcher Servlet)에 요청이 전달되기 전/후에 URL 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다.
- `공통된 보안 및 인증/인가 관련 작업`, `모든 요청에 대한 로깅 또는 감사`, `이미지/데이터 압축 및 문자열 인코딩` 등 `Spring과 무관하게 전역적으로 처리해야 하는 작업`에 사용된다
- 인터셉터보다 앞 단에 동작하므로 전역적으로 해야하는 보안 검사(XSS 방어 등)를 하여 올바른 요청이 아닐 경우 차단할 수 있다
- 웹 컨테이너(Servlet Container)에서 동작한다
#### 인터셉터(Interceptor)
필터와 달리 스프링(Spring)이 제공하는 기술로, 디스패처 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.
- `클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업`들을 처리하는데에 사용된다
- `세부적인 보안 및 인증/인가 공통작업`, `API 호출에 대한 로깅 또는 감사`, `Controller로 넘겨주는 정보(데이터)의 가공` 등에 사용된다
- 필터와 달리 스프링 컨텍스트(Spring Context)에서 동작한다

### 8. 객체지향 프로그래밍 (OOP)
***
실제 세계의 사물을 객체로 모델링하여 프로그램을 구성하는 방식
* 데이터와 기능을 하나의 단위로 묶어 관리하기 때문에 코드의 `재사용성`과 `유지보수성`이 향상된다
* ex) 은행 시스템 - 계좌, 고객, 직원 등을 클래스로 정의
      각 클래스는 해당 객체의 상태를 나타내는 속성 (`계좌번호, 잔액, 고객명, 등`)을 가지고
      행동을 나타내는 속성 (`입금하기, 출금하기, 고객정보 업데이트하기, 등`)을 가질 수 있다

### 8-1. 객체지향의 4대 특성 `캡상추다`
***
1. 캡슐화 : 데이터와 코드의 형태를 외부에서 알 수 없게 하고, 데이터의 구조와 역할, 기능을 하나의 캡슐로 만들어 정보를 은닉하는 방법
2. 상속 : 부모 클래스에 정의된 변수나 메서드를 자식 클래스에서 상속받아 사용하는 방법
3. 추상화 : 복잡한 시스템이나 데이터를 단순화하는 프로세스, 클래스의 공통적인 특성(변수, 메서드) 들을 묶어 표현하는 것
4. 다형성 : 어떤 한 요소에 여러 개념을 넣어 놓는 것으로, 대표적으로 `오버라이딩`(_같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것_)
이나 `오버로딩` (_같은 이름의 메서드가 파라미터의 갯수가 자료형에 따라 다른 기능을 하는 것_)이 있다.

## 9. 데이터베이스(Database)
### 9-1. RDBMS vs NoSQL
***
#### RDBMS
관계형 데이터베이스로 고정된 행`row`과 열`column`로 구성된 테이블에 데이터를 저장한다. 데이터 스키마가 명확하게 정의되어 있으며 각 `데이터를 중복없이 한 번만 저장`하고 `데이터무결성을 보장`한다.
- 보통 수직적 확장이 가능하다
- RDBMS는 중복이 없어 데이터 변경이 용이하기 때문에, 관계를 맺고 있는 데이터가 자주 변경되는 시스템에 사용한다
#### NoSQL
관계형 데이터베이스가 아닌 나머지 유형들을 말하며, 주로 문서, 키 값, 와이드 컬럼, 그래프가 있다. 유연한 스키마를 제공하며 확장이 용이하다.
데이터 중복을 계속 업데이트 해야 한다는 단점이 있다.
- 수평적 확장이 가능하다

### 9-2 데이터베이스 스키마 
***
DB 구조와 제약조건에 관한 전반적인 명세를 정의한 메타데이터(Meta Data)의 집합
- `속성(Attribute)`, `개체(Entity)`, `관계(Relation)` 에 대한 정의를 포함, 이들이 지켜야 하는 제약조건을 기술한 것을 말한다.

### 9-3. 데이터베이스 옵티마이저(Optimizer)
***
SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부 핵심엔진

### 9-4. JPA (Java Persistence API)
***
Java 진영에서 ORM(Object-Realational Mapping `객체 관계형 매핑`) 기술 표준으로 사용되는 인터페이스의 모음(프레임워크)으로,
JPA를 구현한 대표적인 오픈소스로는 `Hibernate`가 있다
- SQL이 아닌 객체 중심으로 개발할 수 있다. (생산성이 좋아지고, 유지보수가 수월해진다)
- JPA는 반복적인 CRUD SQL을 처리해준다. (개발자는 어떤 SQL이 실행될지 생각만 하면 되고, 예측도 쉽게 할 수 잇다)

### 9-5. 인덱스(Index)
***
#### 인덱스의 구조
대부분의 RDBMS에서 사용하는 인덱스는 B-트리(Balanced Tree)나 B+ 트리(Balanced Plus Tree) 구조를 기반으로 한다.
- 계층 구조: 루트 노드, 중간 노드, 리프 노드로 구성된 트리 형태이다
- 균형 유지: 트리의 높이가 항상 일정하게 유지되어, 어떤 데이터를 검색하더라도 유사한 시간이 소요된다
- 리프 노드: 실제 데이터가 위치하거나 데이터의 포인터를 가지고 있다
1. 인덱스 생성
   - 데이터베이스 테이블에 인덱스를 생성하면, 해당 테이블의 특정 열(Column)에 대해 인덱스가 생성된다.
   - 이 인덱스는 해당 컬럼의 값들을 정렬된 상태로 유지하면서 그에 대한 포인터를 포함하며, 포인터는 실제 데이터가 저장된 위치를 가리킨다.
2. 데이터 검색(SELECT)
   - 인덱스가 존재하는 컬럼에 대해 검색이 이루어지면, 데이터베이스는 `전체 테이블을 스캔하는 대신 인덱스를 먼저 탐색`한다.
   - 특정 값에 대한 검색이 들어오면, B-Tree 구조의 인덱스는 빠르게 해당하는 값을 찾아내고, 그 값이 저장된 테이블의 위치를 반환한다.
3. 삽입, 갱신, 삭제 시 작동
   - 삽입(INSERT) : 새로운 데이터가 삽입될 때, 인덱스도 함께 업데이트되어야 한다. 트리 구조에서 적절한 위치에 새로운 값이 삽입되고 트리가 균형을 유지하도록 재조정된다.
   - 갱신(UPDATE) : 특정 값이 업데이트될 때, 인덱스도 영향을 받는다. 업데이트된 값이 인덱스 컬럼에 해당하면, 해당 값의 위치가 인덱스에서 수정된다.
   - 삭제(DELETE) : 값이 삭제되면, 해당 값에 대한 인덱스 항목도 삭제된다. 이 과정에서 트리의 균형이 다시 맞춰질 수 있다.
#### 인덱스의 장단점
#### 장점
- 검색 속도 향상 (전체 테이블을 스캔하지 않고도 데이터를 빠르게 찾을 수 있다)
- 정렬 속도 향상 (특정 컬럼에 대해 정렬된 결과를 빠르게 얻을 수 있다)
#### 단점
- 저장 공간 사용 (인덱스를 유지하기 위해 추가적인 저장 공간이 필요하다)
- 쓰기 작업의 성능 저하 (데이터 삽입/갱신/삭제 시 인덱스도 함께 업데이트해야 하므로, 성능이 저하될 수 있다)

</br>RDBMS에서 인덱스는 데이터 검색을 효율적으로 하는 데 중요한 역할을 하지만, 인덱스 생성 및 관리에 따른 비용이 있으므로 신중하게 사용해야 한다.
- 인덱스는 주로 검색 빈도가 높은 열에 적용하며, 필요 없는 인덱스는 성능을 저하시키므로 제거해야 한다
- 수정이 발생하면, 트리의 균형을 위해 B-Tree 위치가 조정되기 때문에 수정 작업이 빈번하게 일어나는 컬럼은 인덱스로 설정하면 안된다
### 9-6. 클러스터드 인덱스(Clustered Index) vs 넌 클러스터드 인덱스(Non Clustered Index)
***
#### 클러스터드 인덱스
특정 열(Column) 또는 여러개의 열(Row)들을 기준으로 데이터가 정렬 가능하게 하는 자료구조
- 테이블 자체를 인덱스로 만드는 형태로, `테이블 당 1개`씩만 허용된다.
- 데이터가 많고 `SELECT` 문 수행이 많은 경우 효과적이다.
- `BETWEEN, \<, \>, \=` 와 같이 범위 값을 반환하는 쿼리에 효과적이다.
- `ORDER BY`, `GROUP BY`, `JOIN` 조건으로 사용되는 경우 클러스터드 인덱스를 활용하면 효과적이다.
- 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지한다.
- `물리적으로 행을 재배열`한다. (원본이 정렬된다)
- PK 설정 시 그 컬럼은 자동으로 클러스터드 인덱스가 만들어진다.
- 넌 클러스터드 인덱스보다 검색 속도는 더 빠르지만 데이터의 입력, 수정, 삭제는 느리다.

#### 넌 클러스터드 인덱스
인덱스 페이지에 데이터가 직접 저장되지 않고 자료의 주소가 저장되는 구조
- 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다.
- 클러스터드 인덱스보다 `SELECT` 속도는 느리지만, 비교적 데이터의 변경 면에서는 더 빠르다.
- 한 테이블당 여러 개의 넌 클러스터드 인덱스 설정이 가능하다.
- 인덱스를 생성할 때 데이터 페이지는 그대로 둔 상태에서 별도의 인덱스 페이지를 만들기 때문에 용량을 더 차지한다.

##### 차이점
- 클러스터드 인덱스 : 페이지를 알기 때문에 바로 그 페이지를 펴는 것
- 넌 클러스터드 인덱스 : 뒤에 목차에서 찾고자 하는 내용의 페이지를 찾고 그 페이지로이동하는 것
- 테이블 스캔 : 처음부터 한 장씩 넘기면서 찾는 것

## 10. Java
#### 장점
1. Java는 Cross-Platform(플랫폼독립성) 언어로 하나의 소스 코드로 여러 운영체제에서 실행이 가능하다 `운영체제에 독립적`. (단, JVM이 설치된 환경에서만)
2. 객체지향 언어이다. (객체지향의 특징인 `캡슐화`, `상속`, `추상화`, `다형성`이 잘 적용된 언어로, 객체지향 패러다임의 특성 상 비교적 이해하고 배우기 쉽다)
3. JVM에서 가비지 콜렉터(Garbage Collector)가 데몬 쓰레드에 의해 자동으로 메모리를 관리해준다. (GC로 인해 별도의 메모리 관리가 필요 없다)
4. 오픈소스이다. (OpenJDK의 경우)
5. 멀티 쓰레드를 지원한다. (쓰레드 생성 및 제어에 관련된 라이브러리 API를 제공하고 있어 쉽게 구현할 수 있다)
6. 동적 로딩을 지원한다. (각 객체가 필요한 시점에 클래스를 동적 로딩하여 생성한다)
#### 단점
JVM에 의존하기 때문에 다른 프로그래밍 언어보다 느릴 수 있다.

### 10-1. Java의 main 메서드가 static인 이유
***
`public static void main(String args[]){...}` 메인 메서드는 프로그램이 실행되는 시작과 끝이 되는 지점으로,
JRE는 프로그램 안에 main() 메서드가 있는지 확인한 후 main() 메서드를 실행하게 된다.
main() 메서드가 끝나면 JRE는 JVM을 종료하고, JRE 자체도 메모리에서 사라지게 된다.
- public : 어디에서나 접근이 가능해야 한다
- static : 프로그램 실행 순간에 메모리에 할당되어야 한다. (가비지 컬렉터의 정리 대상이 되어서는 안된다)
- void : main() 메서드가 끝나게 되면 프로그램도 종료되므로 리턴값을 사용할 호출자가 없다.
- main() : 관례적으로 프로그램의 시작점을 main 으로 사용한다.
- String args[] : 프로그램 실행 시 첫 쓰레드인 main에게 데이터를 넘겨주고 싶을 경우를 위한 파라미터이다.

### 10-2. 서블릿(Servlet)
***
Java에서 HTTP 요청과 응답을 처리하기 위한 환경을 제공하는 Java 기반의 서버 사이드 기술
- 클라이언트의 요청을 받아 동적인 웹 페이지를 생성하기 위한 기술로 JSP와 함께 많이 사용된다. (JSP는 내부적으로 서블릿으로 변환되어 실행된다)

### 10-3. Java Reflection(리플렉션)
***
Reflection 이란 구체적인 ClassType을 알지 못하더라도, Class의 Method, Type, Variable 에 접근할 수 있도록 해주는 API이다.
- 컴파일된 바이트코드를 통해 Runtime에 동적으로 특정 클래스의 정보를 추출할 수 있도록 해주는 프로그래밍 기법이다.

### 10-4. Enum
***
Enum은 `열겨형(Enumerated Type)`을 의미하며 서로 연관된 상수들의 집합을 의미한다.
서로 연관된 상수를 사용하여 코드 가독성이 좋아지며, 인스턴스 생성과 상속을 방지하여 상수값의 타입 안정성이 보장된다.
- ex) 성별(Gender) - MALE, FEMALE

### 10-5. Stack vs Heap
***
#### 스택(Stack)
함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역으로, 스택 영역은 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다.
- LIFO(후입선출, Last-In-First-Out) 방식에 따라 동작
- 잠깐 사용하고 삭제하는 데이터를 저장한다 (지역변수, 매개변수)
- 해당 객체가 정의된 블록(Scope)을 벗어날 때 소멸된다
- 기본 자료형(`char, int, double`)은 메모리의 Stack 영역에 저장된다
- Heap 보다 빠른 속도

#### 힙(Heap)
사용자가 직접 관리할 수 있는 메모리 영역으로, 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다. 
- 동적 메모리 할당 (Java의 new)
- 메모리 크기 제한이 없음
- Stack 보다 큰 메모리를 할당받기 위해 사용한다
- 참조 자료형(`클래스, 인터페이스, 배열, enum`)은 메모리의 Heap 영역에 저장되며, 참조하는 변수가 없을 때 `GC`에 의해 파괴된다
- Stack에 비해 상대적으로 느린 속도

### 10-6. Java 모듈화 설계 방식
***
코드의 재사용성과 유지보수성을 높이고, 시스템의 확장성을 확보하기 위한 다양한 설계 방법론과 패턴
##### 1. 패키지 구조화 
1) 기능별 패키지 분리<br>
기능별로 패키지를 나누어 코드의 응집성을 높인다<br>
예를 들어, controller, service, repository와 같이 계층별로 패키지를 구분하여 각 계층의 책임을 명확히 하고, 유지보수성을 높인다
2) 도메인 기반 패키지 구조<br>
도메인(비즈니스 개념) 기반으로 패키지를 구분하여 관련 기능이 한 패키지에 모이도록 설계한다<br>
예를 들어, user, order, product와 같이 도메인 개념에 따라 패키지를 나눈다
##### 2. 클래스 설계와 인터페이스 분리
1) 단일 책임 원칙 (SRP, Single Responsibility Principle)<br>
각 클래스는 하나의 책임만 가지도록 설계한다<br>이를 통해 클래스가 더 작고 관리하기 쉬워지며, 변경에 대한 영향을 최소화할 수 있다
2) 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)<br>
클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 작게 나누어 설계한다
<br>이를 통해 인터페이스의 모듈화가 촉진된다
##### 3. 의존성 주입 (Dependency Injection)
1) Spring의 DI (Dependency Injection) 프레임워크 사용<br>
Spring Framework를 활용하여 객체 간의 의존성을 외부에서 주입받도록 설계한다<br>
이를 통해 모듈 간의 결합도를 낮추고, 코드의 유연성과 테스트 가능성을 높인다
2) IoC (Inversion of Control) 원칙<br>
객체의 생성과 라이프사이클을 외부에서 관리하도록 하여 모듈의 독립성을 유지한다
##### 4. 모듈화 아키텍처
1) 서비스 지향 아키텍처 (SOA, Service-Oriented Architecture)<br>
서비스 단위로 기능을 모듈화하여 독립적인 서비스로 개발, 배포, 운영이 가능하도록 한다<br>
각 서비스는 독립적으로 배포될 수 있으며, 다른 서비스와 통신할 때 API를 사용한다
2) 마이크로서비스 아키텍처 (MSA, Microservices Architecture)<br>
애플리케이션을 작은 독립적인 서비스들로 분리하여 모듈화한다<br>
각 마이크로서비스는 독립적으로 배포 및 확장 가능하며, 서로 다른 기술 스택을 사용할 수도 있다
##### 5. Java 9의 모듈 시스템 (JPMS)
1) Java Platform Module System (JPMS)<br>
Java 9부터 도입된 모듈 시스템을 사용하여 애플리케이션을 모듈 단위로 분리한다<br>
각 모듈은 명시적으로 의존성과 접근성을 정의할 수 있으며, 모듈 경계를 통해 코드의 은닉성과 재사용성을 강화할 수 있다
2) module-info.java<br>
각 모듈의 의존성과 공개 API를 정의하는 데 사용된다<br>
이를 통해 애플리케이션의 구조를 명확히 하고, 모듈 간 의존성을 관리한다
##### 6. 디자인 패턴 활용
1) 팩토리 패턴 (Factory Pattern)<br>
객체 생성 로직을 별도의 모듈로 분리하여 코드의 재사용성을 높인다
2) 전략 패턴 (Strategy Pattern)<br>
행위에 대한 모듈화를 통해 알고리즘을 캡슐화하고, 런타임에 교체할 수 있도록 설계한다
3) 데코레이터 패턴 (Decorator Pattern)<br>
객체의 기능을 동적으로 확장할 수 있도록 설계하여 모듈의 유연성을 높인다
### 11. 세션(Session) vs 쿠키(Cookie)
***
#### 세션
웹 서버가 여러 요청 간에 사용자의 상태를 추적하는 방법으로, 서버에서만 접근이 가능하다
#### 쿠키
공개 가능한 정보를 사용자의 브라우저에 저장하는 방법으로, 클라이언트와 서버 모두 접근이 가능하다

### 12. React.js vs Vue.js
***
React(리액트)는 UI `라이브러리`이고 Vue(뷰)는 `프레임워크`
- 리액트는 자바스크립트 문법을 응용하여 개발자에 따라 자유로운 개발이 가능하다
- 뷰는 프레임워크 사용에 지정된 문법 방식으로만 개발할 수 있다
- 뷰는 일명 프로그레시브(progressive) 프레임워크라고 칭하며, 일반적인 프레임워크보다 더 자유도가 높고 시스템 수준에 따라 프레임워크의 활용도를 결정할 수 있게 설계되었다
### 12-1. React
***
#### 장점
1. 가상 DOM을 사용해서 갱신되는 싱글 페이지 어플리케이션의 리플로우와 리페인트를 최소화하여 성능을 최적화 시킨다
2. 단방향 데이터 바인딩으로 안정성이 보장된다
3. 컴포넌트 기반의 아키텍쳐를 가지고 있어, 재사용 가능한 컴포넌트는 생산성과 유지보수를 용이하게 한다
#### 단점
1. 앱의 규모가 커지면 속도가 느려진다
2. View 이외의 데이터 모델링 등은 직접 구현하거나 라이브러리를 사용해야 해서, JavaScript에 대한 지식이 필요하다
3. 데이터 모델링, 라이팅, Ajax 등 기능 지원이 되지 않는다
### 12-2. Vue
***
#### 장점
1. 양방향 데이터 바인딩 방식 이용
2. 컴포넌트 기반 프레임워크로 가상 DOM 랜더링 방식을 사용해, 화면 전체를 다시 그리지 않고 프레임워크에서 정의한 방식에 따라 화면이 갱신되어 유지보수와 재사용성이 높다
3. HTML, CSS, JS 만 알고 있어도 사용이 가능해 배우기 쉽다.
#### 단점
1. 테스트가 어렵고 재 구조화가 쉽지 않다
2. 모바일 지원이 부족하다
3. React에 비해 커뮤니티 등 자료가 많지 않다

### 13. MSA vs Monolithic Architecture
***
#### MSA (Micro Service Architecture)
여러개의 서로 작은 서비스로 구성되어 각 서비스가 독립적으로 개발되고 배포되는 구조
#### 모놀리식 아키텍쳐 (Monolithic Architecture)
하나의 어플리케이션이 하나의 서비스로만 이루어진 구조